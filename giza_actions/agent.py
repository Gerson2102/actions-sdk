import os
import asyncio
import json
import time
from contextlib import contextmanager
from typing import Dict, Optional

import requests
from ape import Contract, accounts, networks
from eth_account import Account
from eth_account.messages import SignableMessage
from eth_typing import Address
from giza import API_HOST
from giza.client import EndpointsClient, JobsClient, ProofsClient
from giza.schemas.jobs import JobCreate
from giza.utils.enums import JobKind, JobSize, JobStatus
from pydantic import BaseModel
from web3 import Web3
from web3.exceptions import ContractCustomError, TimeExhausted

from giza_actions.model import GizaModel

logger = logging.getLogger(__name__)

class ProofType(BaseModel):
    address: Address # Who is the signer?
    model_id: int # The model being used for inference
    version_id: int # The version of the model in reference
    endpoint_id: int # The endpoint of the deployed model
    
    class Config:
        protected_namespaces = ()
    
class ProofMessage(BaseModel):
    proofType: ProofType
    
#TODO: Add functions for updating contract, chain id, and endpoint uri
class GizaAgent(GizaModel):
    """
    A blockchain AI agent that helps users put their Actions on-chain. Uses Ape framework and GizaModel to verify a model proof off-chain, sign it with the user's account, and send results to a select EVM chain to execute code.

    Attributes:
        model (GizaModel): The model that this deployer uploads proofs for. This model must have the following fields: id, version, orion_runner_service_url in order to work. This is because all on-chain models require a proof to be generated by Orion Runner.
        inference: The result of the GizaModel inference
        request_id: The request_id of the proof to fetch from the GCP
        proof: The proof from GCP that we will use to verify, sign, and send along with inference data
        

    Methods:
        infer: Runs model inference and retrieves the model output
        get_model_data: retrieves the proof from GCP given the request_id, version_id, endpoint_id, and internal model_id
        generate_calldate: generates calldata for a given smart contract function
        verify: verifies the proof locally
        deploy: verifies the proof, then calls the smart contract with calldata from inference
    """

    # TODO: (GIZ 502) Find a way to abstract away the chain_id to just a string with the chain name
    def __init__(
        self,
        contract_address: str,
        chain: str,
        account: str,
        id: Optional[int] = None,
        version: Optional[int] = None,
        proof_options: Optional[Dict] = None,
        **kwargs,
    ):
        """
        Args:
            contract_address (str): The address of the contract.
            chain_id (int): The ID of the blockchain network.
            id (Optional[int]): Optional ID (default: None).
            version (Optional[int]): Optional version (default: None).
            **kwargs: Additional keyword arguments.
        """
        super().__init__(id=id, version=version, **kwargs)
        self.contract_address = contract_address
        self.chain = chain
        self.account = account
        self.proof_options = proof_options if proof_options else {}
        self.jobs_client = JobsClient(API_HOST)
        self.proofs_client = ProofsClient(API_HOST)

        # Here we save the results of calling predict by order of execution
        self.verifiable = False
        self._results = []
        self._finished_proofs = []

    @contextmanager
    def execute(self):
        """
        Execute the agent in the given ecosystem. Return the contract instace so the user can execute it.

        Args:
            ecosystem: The ecosystem to execute the agent in.
        """
        if self.verifiable:
            provider = networks.parse_network_choice(self.chain)
            logger.debug("Provider configured")
            with provider:
                self._account = accounts.load(self.account)
                logger.debug("Account loaded")
                self._account.set_autosign(
                    True, passphrase=os.getenv(f"{self.account.upper()}_PASSPHRASE")
                )
                logger.debug("Autosign enabled")
                with accounts.use_sender(self._account):
                    yield Contract(self.contract_address)
        else:
            logger.error("Inference is not verifiable. No proof was generated.")
            raise ValueError("Inference is not verifiable. Cannot execute contract.")

    def predict(
        self,
        input_file: Optional[str] = None,
        input_feed: Optional[Dict] = None,
        verifiable: bool = False,
        fp_impl="FP16x16",
        custom_output_dtype: Optional[str] = None,
        job_size: str = "M",
    ):
        """
        Runs a round of inference on the model and saves the result.
        
        Args:
            input_file: The input file to use for inference
            input_feed: The input feed to use for inference
            job_size: The size of the job to run
        """
        result = super().predict(
            input_file=input_file,
            input_feed=input_feed,
            verifiable=verifiable,
            fp_impl=fp_impl,
            custom_output_dtype=custom_output_dtype,
            job_size=job_size,
        )

        self.verifiable = verifiable

        if not verifiable:
            logger.warning(
                "Inference is not verifiable. No request ID was returned. No proof will be generated."
            )

        self._results.append(result)

        return result

    def _retrieve_current_jobs(self, request_ids: list[str]):
        jobs = self.endpoints_client.list_jobs(self.endpoint_id).root

        return [job for job in jobs if job.request_id in request_ids]

    def _wait_for_proof(self):
        """
        Wait for the proofs to be generated.

        Args:
            request_id: The request ID of the proof
        """
        start_time = time.time()
        timeout = start_time + self.proof_options.get("timeout", 600)

        request_ids = [request_id for _, request_id in self._results]
        logger.debug(f"Request IDs: {request_ids}")

        jobs = self._retrieve_current_jobs(request_ids)

        # This will end the loop once all the jobs are completed or failed
        while True:
            now = time.time()
            # If there are no jobs because they have not been created, wait until the timeout
            if len(jobs) == 0:
                logger.info("Proving jobs have finished")
                break

            # If there are jobs but timeout has been reached then raise an error
            if now > timeout:
                logger.error("Proof retrieval timed out")
                raise TimeoutError("Proof retrieval timed out")

            # If there are jobs, check their status
            jobs = self._retrieve_current_jobs(request_ids)
            poll = False
            for job in jobs:
                if job.status == JobStatus.COMPLETED:
                    logger.info(f"Proof {job.request_id} completed")
                    verify_job = self._start_verify_job(job.request_id)
                    self._finished_proofs.append((job.request_id, verify_job))
                    request_ids.remove(job.request_id)
                elif job.status == JobStatus.FAILED:
                    logger.error(f"Proof {job.request_id} failed")
                    raise ValueError(f"Proof {job.request_id} failed")
                else:
                    poll = True
                    logger.info(f"Proof {job.request_id} is still running")
            if poll:
                time.sleep(self.proof_options.get("poll_interval", 5))
                logger.debug(f"Jobs: {jobs}")

    def _start_verify_job(self, request_id: str):
        """
        Verify the proofs.
        """
        # Get the actual proof ID
        proof_id = self.endpoints_client.get_proof(self.endpoint_id, request_id).id

        job_create = JobCreate(
            size=JobSize.S,
            framework=self.framework,
            model_id=self.model_id,
            version_id=self.version_id,
            proof_id=proof_id,
            kind=JobKind.VERIFY,
        )
        logger.debug(f"Job create: {job_create}")
        # Start the verify job without downloading the proof
        verify_job = self.jobs_client.create(job_create, trace=None)
        logger.debug(f"Verify job: {verify_job}")
        logger.info(
            f"Verify job created with ID {verify_job.id} for proof {proof_id} and request {request_id}"
        )
        return verify_job

    def _check_verify_jobs(self):
        """
        Check the status of the verify jobs.
        """
        # TODO: find infinite loop condition, break for and break while
        # Until everything is completed of something fails
        while True:
            updated_list = []
            # Get current status of all the jobs
            for req_id, job in self._finished_proofs:
                # If completed add to the list as is
                if job.status == JobStatus.COMPLETED:
                    if all(
                        job.status == JobStatus.COMPLETED
                        for _, job in self._finished_proofs
                    ):
                        logger.info("All verify jobs completed")
                        return False
                    logger.info(f"Verify job {job.id} completed")
                    updated_list.append((req_id, job))
                elif job.status == JobStatus.FAILED:
                    logger.error(f"Verify job {job.id} failed")
                    raise ValueError(f"Verify job {job.id} failed")
                # If still running, add to the list after updating
                else:
                    logger.info(f"Verify job {job.id} is still running")
                    verify_job = self.jobs_client.get(
                        job.id, params={"kind": JobKind.VERIFY}
                    )
                    updated_list.append((req_id, verify_job))
            self._finished_proofs = updated_list
            time.sleep(self.proof_options.get("poll_interval", 5))

    def verify(self):
        """
        Verify the proofs.
        """
        if self.verifiable:
            self._wait_for_proof()
            self._check_verify_jobs()
        else:
            logger.warning("Inference is not verifiable. No proof was generated.")
            return False
        return True

    # TODO: (GIZ500) Find a way to match function name with the specific function in the contract regardless of spaces, caps, etc. ALSO, add a method to bind types to the parameters
    async def _generate_calldata(self, function_name: str, parameters: list):
        """
        Generate calldata for calling a smart contract function

        Args:
            contract_address (str): Address of the contract
            chain_id (int): ID of the Ethereum chain
            function_name (str): Name of contract function to call
            parameters (list): Arguments to pass to the function

        Returns:
            str: Hex string of calldata
        """
        web3 = Web3()
        
        try:
            abi = fetch_abi(self.contract_address, self.chain_id)
        except ValueError as e:
            raise ValueError(f"Error fetching contract ABI: {str(e)}") from e
        
        function_abi = next((item for item in abi if 'name' in item and item['name'] == function_name), None)
        
        if function_abi is None:
            raise ValueError(f"Function {function_name} not found in ABI")
        
        contract = web3.eth.contract(address=self.contract_address, abi=abi)
        calldata = contract.encodeABI(function_name, args=parameters)
        return calldata
            
    def sign_proof(self, account: Account, proof: ProofMessage):
        """
        Signs a ProofMessage attesting to the on-chain action result
        
        Args:
            account (Account): The account object used to sign the proof
            proof (ProofMessage): The proof message to sign
        Returns:
            sig: The signature of the proof
            proofMessage: The proof message that was signed
            signable_message: The full message that was signed (with some EIP-191 headers and versioning)
            
        """
        address = account.address
        
        proofType = ProofType(address=address, model_id=self.model_id, version_id=self.version_id, endpoint_id=self.endpoint_id)
        proofMessage = ProofMessage(proofType=proofType)
        
        version = b'\x19'
        header = b''
        
        if isinstance(proof, str):
            body = proof.encode('utf-8')
        else:
            body = proofMessage
        signable_message = SignableMessage(version=version, header=header, body=body)
        sig = account.sign_message(signable_message)
        return (sig, proofMessage, signable_message)

    async def transmit(
        self,
        account: Account,
        function_name: str,
        params,
        value,
        signed_proof: SignableMessage,
        proofMessage: ProofMessage,
        signedProofMessage,
        rpc_url: Optional[str],
        proofsig_enabled: bool = False,
    ):
        """
            Transmit: Verify the proof signature (if proofsig_enabled is True), verify the proof, then send the transaction to the contract.

            Args:
                account (Account): The account object used to sign the transaction.
                function_name (str): The name of the contract function to call.
                params: The parameters to pass to the contract function.
                value: The value (in Wei) to send with the transaction (optional).
                signed_proof (SignableMessage): The signed proof message.
                proofMessage (ProofMessage): The proof message object.
                signedProofMessage: The signed proof message.
                rpc_url (Optional[str]): The URL of the RPC endpoint to use (optional).
                proofsig_enabled (bool): Whether to enable proof signature verification or not (default: False).

            Returns:
                A transaction receipt
        """

        web3 = Web3()

        if proofsig_enabled:
            v, r, s = signed_proof.v, signed_proof.r, signed_proof.s
            signed_proof_elements = (v, r, s)
            signer = web3.eth.account.recover_message(signedProofMessage, signed_proof_elements)
            assert signer.lower() == account.address.lower()
            logger.info("Proof signature verified! 🔥")

        assert await self.verify(proofMessage.proofType.proof_path)
        logger.info("Proof verified! ⚡️")

        logger.info("All good! ✅ Sending transaction...")

        try:
            if rpc_url is not None:
                web3 = Web3(Web3.HTTPProvider(rpc_url))
            else:
                alchemy_url = os.getenv("ALCHEMY_URL")
                web3 = Web3(Web3.HTTPProvider(alchemy_url))
            nonce = web3.eth.get_transaction_count(account.address)
            try:
                calldata = await self._generate_calldata(function_name, params)
            except KeyError as e:
                logger.info(f"Error generating calldata: {str(e)}")
                raise
            try:
                transaction = {
                    "to": self.contract_address,
                    "from": account.address,
                    "data": calldata,
                    "nonce": nonce,
                    "gas": web3.eth.estimate_gas({"to": self.contract_address, "data": calldata}),
                    "gasPrice": web3.eth.gas_price,
                    "chainId": self.chain_id
                }
                if value is not None:
                    transaction["value"] = value
            except KeyError as e:
                logger.info(f"Error creating transaction dictionary: {str(e)}")
                raise
            logger.info(f"Transaction: {transaction}")
            try:
                signed_tx = account.sign_transaction(transaction)
            except KeyError as e:
                logger.info(f"Error signing transaction: {str(e)}")
                raise
            logger.info(f"Signed transaction: {signed_tx}")
            try:
                tx_hash = web3.eth.send_raw_transaction(signed_tx.rawTransaction)
            except ValueError as e:
                logger.info(f"Error sending transaction: {str(e)}")
                return None
            except Exception as e:
                logger.info(f"Error sending transaction: {str(e)}")
                return None
            try:
                receipt = web3.eth.wait_for_transaction_receipt(tx_hash, timeout=300)
                logger.info("Transaction Completed.")
                return receipt
            except TimeExhausted:
                logger.info("Transaction receipt retrieval timed out.")
                return None

            except asyncio.TimeoutError:
                logger.info(
                    "Transaction receipt retrieval timed out after 300 seconds."
                )
                return None

        except ValueError as e:
            logger.info(f"Error encoding transaction: {e}")
            return None

        except ContractCustomError as e:
            logger.info(f"Custom error occurred: {e}")
            logger.info(f"Error message: {e.args[0]}")
            return None

        except Exception as e:
            logger.info(f"Error transmitting transaction: {str(e)}")
            logger.info(f"Exception type: {type(e)}")
            return None
    
        
        
def get_endpoint_id(model_id, version_id):
    """
    Retrieve the endpoint ID for the model and version.

    Returns:
        int: The ID of the endpoint.
    """
    client = EndpointsClient(API_HOST)
    return client.list(model_id, version_id).root[0].id

def fetch_abi(contract_address, chain_id):
    api_key = os.getenv("ETHERSCAN_API_KEY")
    if not api_key:
        raise ValueError("ETHERSCAN_API_KEY environment variable not set")
    
    if chain_id == 1:
        etherscan_url = "https://api.etherscan.io/api"
    elif chain_id == 11155111:
        etherscan_url = "https://api-sepolia.etherscan.io/api"
    elif chain_id == 5:
        etherscan_url = "https://api-goerli.etherscan.io/api"
    else:
        raise ValueError("Unsupported chain ID")
    
    url = f"{etherscan_url}?module=contract&action=getabi&address={contract_address}&apikey={api_key}"
    
    response = requests.get(url)
    response_json = response.json()
    
    if response_json["status"] == "1":
        abi = response_json["result"]
        return json.loads(abi)
    else:
        raise ValueError(f"Failed to retrieve contract ABI: {response_json['message']}")
